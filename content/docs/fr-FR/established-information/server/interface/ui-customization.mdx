---
title: Personnalisation de l'interface utilisateur
description: Informations à propos de la personnalisation de l'interface utilisateur dans Hytale.
---

L'interface utilisateur peut être personnalisée par le modding **côté-serveur**. La plupart des pages d'interface utilisateur montrées aux joueurs peuvent être modifiées par les propriétaires de serveurs à travers des mods.

## La personnalisation de l'interface utilisateur dans Hytale

Hytale offre des fonctionnalités étendues de personnalisation de l'interface utilisateur par le modding côté-serveur, permettant aux propriétaires de serveurs de modifier un grand nombre des pages d'interface utilisateur avec lesquelles les joueurs peuvent interagir.

### Flux de contrôle

Le système d'interface utilisateur d'Hytale suit un modèle de flux de contrôle spécifique :

1. Le serveur envoie les données de l'interface utilisateur au client
2. Le client affiche l'interface utilisateur
3. L'utilisateur interagit avec l'interface utilisateur (par exemple : appuyer sur un bouton)
4. Le client envoie l'évènement d'interaction au serveur
5. Le serveur exécute la logique reliée à l'évènement

Cette architecture signifie que :

* Le client est responsable de l'affichage de l'interface utilisateur et d'envoyer les interactions au serveur
* Le serveur gère toute la logique derrière les interactions de l'utilisateur

<Callout type="warning" title="Incidences possibles sur les performances">
  <span>
    Puisque le serveur s'occupe de toute la logique de l'interface utilisateur, il y a un impact inhérent de la latence sur la réactivité de l'interface utilisateur. Les clics sur les boutons et les autres interactions doivent voyager jusqu'au serveur avant de prendre effet, ce qui signifie que la latence du réseau affecte directement la réactivité de l'interface utilisateur.
  </span>

  <span>
    De plus, puisque le modding côté-client n'est pas supporté, aucune valeur moddée ne reste sur le client.
  </span>
</Callout>

### Assets de disposition de l'interface utilisateur

Le système de personnalisation de l'interface utilisateur fonctionne de la manière suivante :

* **Disposition de l'interface utilisateur** : envoyée au client en tant qu'asset
* **Comportement de l'interface utilisateur** : défini en code Java
* **Dispositions personnalisées** : permet la création de dispositions d'interfaces utilisateur sur mesure plutôt que réutiliser celles déjà existantes (à contrario des modifications d'inventaires dans Minecraft)

### Implémentations du framework d'interface utilisateur

Hytale supporte actuellement plusieurs implémentations d'interface utilisateur, et prévoit de se consolider avec NoesisGUI :

#### Ancienne implémentation

* Sert d'exemple des capacités de modding du serveur
* Utilise une combinaison d'éléments en jeu, d'assets de balisage d'interface utilisateur et de code de mod Java
* Utilise un ancien langage de balisage personnalisé
* Sera déprécié en faveur de NoesisGUI

#### NoesisGUI (Framework principal)

* Utilise le langage de balisage XAML pour la définition de l'interface utilisateur
* Prend en charge plusieurs langues pour l'internationalisation
* Fonctionne avec des liaisons C# du côté du client (et non en C++)
* Représente la direction future du système de l'interface utilisateur d'Hytale

#### Troisième Framework

* En cours de suppression progressive
* Sera remplacé par NoesisGUI dans le cadre de l'effort de consolidation

### Considérations relatives aux performances

En raison de la nature côté-serveur du traitement de l'interface utilisateur, il y a des caractéristiques relatives aux performances inhérentes à prendre en compte :

* **Impact de la latence** : Les clics sur les boutons et les autres interactions doivent voyager jusqu'au serveur avant de prendre effet, ce qui signifie que la latence du réseau affecte directement la réactivité de l'interface utilisateur
* **Pas de persistance du client** : Puisque le modding côté-client n'est pas supporté, aucune valeur moddée ne reste sur le client
* **Architecture optimisée** : Le système d'Hytale est conçu pour minimiser la latence à travers des protocoles de communication efficaces et des performances serveur optimisées, garantissant des interactions fluides malgré la nécessité de traitement côté-serveur

L'architecture priorise la sécurité et la cohérence en centralisant la logique de l'interface utilisateur sur le serveur tout en maintenant une expérience utilisateur réactive
